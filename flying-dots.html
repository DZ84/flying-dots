 <!DOCTYPE html>

<!--


Dennis Zethof - Februari 2018

v0.4

NOTE: This version is setup to show that the collision
detection works, and can be started and left alone indefinite.
The code aims to handle collisiondetection independent of
the amount of calculationcycles per second (main_loop_interval). 
It checks for collisions, handles the one that occurs first up
to the point of collision, calculates the effects, evaluates the 
new situation, and then handles the resulting earliest next 
collision.

By all means this code is not finished. It is too inefficient to
do what it is supposed to: run until the box is fully filled 
with dots. In order to achieve this a more efficient way of 
collision detection must be employed; this version uses a mostly
iterative process, so when set at .001, each potential collision
will trigger a 1000 checks. A grid system is in place to limit
the number of times the checking system is triggered, which is a
sort of sweeping type of algorithm, but it it is not enough. It 
should be done much more efficient AND much more precise by using 
a collision detection method that relies more on mathematics.

TODO: 
   	- heavy refactoring
   	- change collision detection system
   	- add polynomial options
 
NICE TO HAVES:
	- rotation of objects
-->


<html>
	<head>
		<script src="https://cdn.anychart.com/js/latest/graphics.min.js"></script>

		<style>

			body {
				background: yellow;
				margin: 0 0 0 0;
			}

            #circle {
                position: absolute; 
                width: 500px;
                height: 500px;
				background: white;
            }

			#timer_div {
				position: absolute;
				bottom: 0; 
			   	width: 100%; 
				text-align: center;
				color: red;
			}

		</style>


		<script type="text/javascript">
		
			// globals

			// set options/constants
			var main_loop_interval = 35				// in milliseconds
			//var loops_per_new_dot = 70		
			var dots_per_second = 0.4
			var circle_resolution = 20				// 2pi/circle_res
			var starting_point = {x: 40, y: 40}


			var settings_decimals_increment = undefined	
			// TODO: this should be under options I guess.
			var settings_decimals_calculations = 9
			var settings_maximum_dots = 10

			// grid system
			var section_size = {x: 20, y: 20}		// in pixels

			var incr_steps = 0.001

			var dots = []							// for debug purposes defined as global
			var grid_positions = []					// for debug purposes defined as global
			var collision_storage = []

			var demo_mode = true
			// debug options
			var debug_main_loop_counter = 0
			var debug = false						// general debug mode
			var debug_coll = false					// debug mode for setting up collision det
			var debug_check_list = []
			var debug_timer_tracker = 0
			var debug_timer = 4.50					// seconds
			var debug_timer_steps = 100			// miliseconds
            window.onload = function() { 
				var loops_before_new_dot = Math.round(dots_per_second/(main_loop_interval/1000))
				debugger
				var loops_since_new_dot = loops_before_new_dot-1
				var new_dot_id = 0
				//var dots = []	
				//var grid_positions = []
				//var collision_storage = []
			
				// some setting that needs to be done
				set_increment_decimals()
				
				var border_objects = [] 
				var grid_border_positions = []
				get_set_border_objects(border_objects)
				set_border_positions(grid_border_positions, border_objects)
				
				var main_loop = setInterval(function() {

					if (debug) {
						debug_main_loop_counter++
					}
					loops_since_new_dot++
					if (loops_since_new_dot==loops_before_new_dot && dots.length<settings_maximum_dots) {
						new_dot_id++
						var new_dot = new Dot(new_dot_id, dots.length)
						dots.push(new_dot)
						loops_since_new_dot = 0
					}	
      
					for (var d=0;d<dots.length;d++) {
						dots[d].determine_next_coords()
						dots[d].manage_sections_setting()
					}

					add_grid_border_positions(grid_positions, grid_border_positions)
					manage_grid_positions(grid_positions, dots)

					find_collisions(collision_storage, grid_positions)
					sort_collision_storage(collision_storage)

					var processed_collisions = false
					while (!processed_collisions) {

						processed_collisions = manage_collision(grid_positions, collision_storage)
					}

					for(var d=0; d<dots.length; d++) {
						dots[d].set_coords()
						dots[d].move()
						dots[d].increment = 0		// this should be reset inside the class
					}

					grid_positions = []
					collision_storage = []

				}, main_loop_interval)
			
			}

			function manage_collision(grid_positions, collision_storage) {

				if (collision_storage.length==0) {
					return true
				}
				
				var info = get_next_collision_info(collision_storage)

				process_collision(info)	
				process_objects(info) 
				process_grid_positions(grid_positions, info)
				process_collision_storage(collision_storage, grid_positions, info)

				return (collision_storage.length==0)
			}

			function process_collision_storage(collision_storage, grid_positions, info) {

				clean_collision_storage(collision_storage, info)
				find_collisions(collision_storage, grid_positions, info)
				sort_collision_storage(collision_storage)

				return
			}

			function process_objects(info) {

				do_section_setting(info.obj_1)
				do_section_setting(info.obj_2)
				info["redo_list"] = create_redo_list(info.obj_1, info.obj_2)

				return
			}

			function process_grid_positions(grid_position, info) {
				
				remove_old_grid_positions(grid_positions, [info.obj_1, info.obj_2])
			
				// make sure only dots are entered in manage_grid_positions	
				var dots_to_add = []
				select_dots(dots_to_add, info)

				manage_grid_positions(grid_positions, dots_to_add)

				return
			}

			function select_dots(dots_to_add, info) {
	
				if (info.obj_1 instanceof Dot) {
					dots_to_add.push(info.obj_1)
				}
				
				if (info.obj_2 instanceof Dot) {
					dots_to_add.push(info.obj_2)
				}

				return
			}

			function do_section_setting(obj) {

				if (obj instanceof Dot) {
					obj.manage_sections_setting()
				}

				return
			}

			function process_collision(info) {
				// NOTE: this is a 1-2 between coords_theory and
				// next_coords_theory. This collision has been
				// as next one so next coords will be used icw
				// the incr to set the new coord. The new course
				// will then be determined, incl. the tracking
				// of that collision, and then icw the new course
				// a new next coord will be determined icw the
				// remaining incr value.	
				var [obj_1, obj_2, incr] = [info.obj_1, info.obj_2, info.incr]

				set_coll_coordinates(obj_1, incr)
				set_coll_coordinates(obj_2, incr)
				handle_object_movement(obj_1)
				handle_object_movement(obj_2)
				
				write_collision(obj_1, obj_2, incr) 

				set_next_coordinates(obj_1)		
				set_next_coordinates(obj_2)		

				return
			}

			function get_next_collision_info(collision_storage) {

				var info = collision_storage[0]
				info.redo_mode = true	

				return info	
			}

			function create_redo_list(obj_1, obj_2) {
				// TODO: redo_list is not ordered, but it's always a very small list
				var redo_list = []
					
				if (obj_1 instanceof Dot) {
					var first = obj_1
					var second = obj_2
				} else if (obj_2 instanceof Dot) {
					var first = obj_2
					var second = undefined
				} else {
					// error..
					debugger
					return redo_list
				}

				for (var gp=0;gp<first.grid_spots.length;gp++) {
					redo_list.push(first.grid_spots[gp])
				}	
				
				if (second instanceof Dot) {
					var found = false
					for (var gp=0;gp<second.grid_spots.length;gp++) {
						found = false
						for (var rl=0;rl<redo_list.length;rl++) {
							if (second.grid_spots[gp]["x"]==redo_list[rl]["x"] 
							 && second.grid_spots[gp]["y"]==redo_list[rl]["y"]) {
								found = true
								break
							}
						}	

						if (!found) {
							redo_list.push(second.grid_spots[gp])
						}
					}
				}

				return redo_list
			}

			function clean_collision_storage(collision_storage, info) {

				if (debug) {
					if (debug_main_loop_counter>669) {
						
					}
				}

				var cl = 0
				while (cl<collision_storage.length) {
					var cl_st = collision_storage[cl]

					if (cl_st.obj_1 instanceof Dot && cl_st.obj_2 instanceof Dot) {
						if (cl_st.obj_1===info.obj_1 || cl_st.obj_1===info.obj_2) { 
							collision_storage.splice(cl, 1)
							continue
						} else if (cl_st.obj_2===info.obj_1 || cl_st.obj_2===info.obj_2) {
							collision_storage.splice(cl, 1)
							continue
						}	
					} else if (!(cl_st.obj_1 instanceof Dot)) {
						if (cl_st.obj_2===info.obj_1 || cl_st.obj_2===info.obj_2) {
							collision_storage.splice(cl, 1)
							continue
						}	
					} else if (!(cl_st.obj_2 instanceof Dot)) {
						if (cl_st.obj_1===info.obj_1 || cl_st.obj_1===info.obj_2) {
							collision_storage.splice(cl, 1)
							continue
						}
					}
					
					if (debug) {
						if (cl>150) {
							
						}
					}

					cl++	
				}
				return
			}

			function set_coll_coordinates(obj, incr) {

				if (obj instanceof Dot) {
						
					obj.coords_theory.x = round_calc_general(obj.coords_theory.x + (obj.course.x * (incr-obj.increment)))
					obj.coords_theory.y = round_calc_general(obj.coords_theory.y + (obj.course.y * (incr-obj.increment))) 

					obj.coords.x = Math.round(obj.coords_theory.x)
					obj.coords.y = Math.round(obj.coords_theory.y)

					obj.increment = incr
				}
					
				return	
			}

			function check_round_incr(incr) {

				return get_rounded_number(incr, settings_decimals_increment)
			}

			function round_calc_general(value) {
				
				return get_rounded_number(value, settings_decimals_calculations)
			}

			function get_rounded_number(value, decimals) {
				// NOTE: if number is smaller than 0.000001, js converts it
				// to scientific notation, which would make the rounding 
				// process crash.
				// NOTE: when value is >= 1000000000000 is also produces
				// NaN, don't know why though. This also: 999999999999.99999, 
				// because js rounds that up (too many digits?).
				if (value<.000001) {
					// NOTE: decimal buffer is to ensure this method does not
					// determine the actual rounding. The number specified
					// however is not determined by any theory.
					var decimal_buffer = 6
					value = Number(value).toFixed(decimals+decimal_buffer).replace(/\.?0+$/,"")
				} else if (value>=1000000000000) {
					console.log("Not yet implemented: error will occur, number was " +
								"larger than possible for current implementation of " +
								"determining decimals.\n" +
								"Calling console.trace() now: ")
					console.trace()
				}

				return Number(Math.round(value+"e"+decimals)+"e-"+decimals)
			}

			function set_increment_decimals() {

				var calculation = 0	
				var p = -1
				var multiplier = undefined
				while (Math.round(calculation)==0) {
					p++
					multiplier = 10**p	
					calculation = multiplier*incr_steps
				}

				settings_decimals_increment = p
				return
			}

			function handle_object_movement(obj) {

				if (obj instanceof Dot) {
					obj.move()
				}

				return
			}

			function set_next_coordinates(obj) {

				if (obj instanceof Dot) {
					obj.next_coords_theory["x"] = round_calc_general(obj.coords_theory["x"] + (obj.course["x"]*(1-obj.increment)))
					obj.next_coords_theory["y"] = round_calc_general(obj.coords_theory["y"] + (obj.course["y"]*(1-obj.increment)))
				}

				return
			}

			function add_grid_border_positions(grid_positions, grid_border_positions) {
				
				for (var gb=0;gb<grid_border_positions.length;gb++) {
					grid_positions.push(grid_border_positions[gb])
				}

				return
			}

			function manage_grid_positions(grid_positions, objects_to_add) {

				for (var d=0;d<objects_to_add.length;d++) {
					for (var gs=0;gs<objects_to_add[d].grid_spots.length;gs++) {
						grid_positions.push(objects_to_add[d].grid_spots[gs])
					}
				}

				sort_grid_positions(grid_positions)
				return
			}

			function remove_old_grid_positions(grid_positions, objects) {
				
				var grid_obj = undefined
				var gp = 0
				var relevant_objects = []
				var found = false

				for (var ob=0;ob<objects.length;ob++) {
					if (objects[ob] instanceof Dot) {
						relevant_objects.push(objects[ob])	
					}
				}

				while (gp<grid_positions.length) {
					grid_obj = grid_positions[gp].obj
					found = false

					for (var ro=0;ro<relevant_objects.length;ro++) {
						if (grid_obj===relevant_objects[ro]) {
							found = true
							break						
						}
					}

					if (found) {
						grid_positions.splice(gp, 1)		
						continue
					}
					gp++
				}
				
				return
			}

			function find_collisions(collision_storage, grid_positions, redo_info={redo_mode: false}) {
				
				var checked_this_round = []
				for (var gp=0;gp<grid_positions.length-1;gp++) {
				
					if (redo_info["redo_mode"]) {
						var redo_position = check_redo_position(grid_positions[gp], redo_info["redo_list"])
					}
					
					// find matches
					if (grid_positions[gp]["x"]==grid_positions[gp+1]["x"]
					 && grid_positions[gp]["y"]==grid_positions[gp+1]["y"]) {
						var store_section = {x: grid_positions[gp]["x"], 
											 y: grid_positions[gp]["y"], 
											 objects_present: [grid_positions[gp]["obj"], 
															   grid_positions[gp+1]["obj"]
															  ]
											}

						var grid_pos_different = find_all_other_doubles(store_section, grid_positions, gp+2)

						gp = grid_pos_different-1			  
						if (redo_info["redo_mode"]) {
							if (!redo_position) {
								continue
							}
						}

						check_section(store_section, checked_this_round, collision_storage, redo_info)
					}
				}
				return
			}

			function check_redo_position(grid_pos, redo_list) {

				for (var rl=0;rl<redo_list.length;rl++) {
					if (grid_pos["x"]==redo_list[rl]["x"] 
					 && grid_pos["y"]==redo_list[rl]["y"]) {
						return true
					}
				}

				return false
			}

			function find_all_other_doubles(store_section, grid_positions, next) {

				for (var gp_2=next;gp_2<grid_positions.length;gp_2++) {
					if (grid_positions[gp_2]["x"]==store_section["x"] 
					 && grid_positions[gp_2]["y"]==store_section["y"]) {
						store_section["objects_present"].push(grid_positions[gp_2]["obj"])
						continue
					}
					break
				}
				return gp_2	
			}

			function check_section(store_section, checked_this_round, collision_storage, redo_info) {
				var obj_list = store_section["objects_present"]

				for (var dl=0;dl<obj_list.length-1;dl++) {
						
					if (redo_info["redo_mode"]) {
						var first_dot_unchanged = undefined
						var second_dot_unchanged = undefined

						if ((obj_list[dl] != redo_info.obj_1
						  && obj_list[dl] != redo_info.obj_2)) {
							first_dot_unchanged = true
						} else {
							first_dot_unchanged = false
						}
					}

					if (obj_list[dl].type=="line") {
						var first_dot_is_line = true
					} else {
						var first_dot_is_line = false
					}

					for (var dl_2=dl+1;dl_2<obj_list.length;dl_2++) {
						

						if (first_dot_is_line && obj_list[dl_2].type=="line") {
							continue
						}

						// TODO: untested
						if (already_checked_this_grid_cycle(checked_this_round, obj_list[dl], obj_list[dl_2])) {
						   continue
						}	   

						if (redo_info["redo_mode"]) {
							if ((obj_list[dl_2] != redo_info.obj_1
							  && obj_list[dl_2] != redo_info.obj_2)) {
								second_dot_unchanged = true
							} else {
								second_dot_unchanged = false
							}
							
							if (first_dot_unchanged && second_dot_unchanged) {
								continue
							}	

							// TODO: this is set after determining whether one is a
							// border, so requesting the increments should be fine.
							if (obj_list[dl].increment==1 || obj_list[dl_2].increment==1) {
								continue
							}
						}
	
						var result = choose_collision_calculation(obj_list[dl], obj_list[dl_2])
						
						checked_this_round.push({obj_1: obj_list[dl], obj_2: obj_list[dl_2]})

						if (result.found) {
							check_add_result(collision_storage, result.log)
						}
					}
				}
				return
			}

			function already_checked_this_grid_cycle(checked_this_round, obj_1, obj_2) {
				for (var c=0;c<checked_this_round.length;c++) {

					if (checked_this_round[c].obj_1===obj_1 
					 || checked_this_round[c].obj_1===obj_2) {

						if (checked_this_round[c].obj_2===obj_1 
					     || checked_this_round[c].obj_2===obj_2) {
							return true
						}
					}
				}
				return false
			}

			function already_in_collision_storage(obj_1, obj_2, collision_storage) {

				for (var cs=0;cs<collision_storage.length;cs++) {

					if (collision_storage[cs].obj_1===obj_1 
					 || collision_storage[cs].obj_1===obj_2) {

						if (collision_storage[cs].obj_2===obj_1 
					     || collision_storage[cs].obj_2===obj_2) {
							return true
						}
					}
				}
				return false
			}

			function check_add_result(collision_storage, log) {
				
				for (var cs=0;cs<collision_storage.length;cs++) {

					if (collision_storage[cs].obj_1===log.obj_1 
					 || collision_storage[cs].obj_1===log.obj_2) {

						if (collision_storage[cs].obj_2===log.obj_1 
					     || collision_storage[cs].obj_2===log.obj_2) {
							return

						}
					}
				}
				collision_storage.push(log)
				return
			}

			function choose_collision_calculation(obj_1, obj_2) {
				// NOTE: this assumes there cannot be two intersecting bordersections.
				// There should not be any doubles, so should be ok.
				// but they're also coincidently filtered out by the previous function.
				// TODO: not the correct name for a function
				if (obj_1 instanceof Dot && obj_2 instanceof Dot) {
					var result = find_collision_dots(obj_1, obj_2)
				} else {
					var result = find_collision_border(obj_1, obj_2)
				}
				
				return result	
			}
		
			function find_collision_border(obj_1, obj_2) {
			
				if (!(obj_1 instanceof Dot)) {
					var temp = obj_1
					obj_1 = obj_2
					obj_2 = temp
				}

				var border = {}
				// is done also when creating the border objects, these comparisons
				// should not be made here. And are done doubly.
				if (obj_2.start.x<obj_2.end.x) {
					border.start = obj_2.start
					border.end = obj_2.end	
				} else if (obj_2.start.x==obj_2.end.x) {
					if (obj_2.start.y>obj_2.end.y) {
						border.start = obj_2.end
						border.end = obj_2.start
					} else {
						border.start = obj_2.start
						border.end = obj_2.end	
					}
				} else {
					border.start = obj_2.end
					border.end = obj_2.start
				}

				if (debug) {
					if (debug_main_loop_counter>184) {
						if (obj_1.id==3 && obj_2.side=="ceiling") {
							
						}
					}
				}

				var result = {found: false, log: undefined}
				var checked = {}
				// check if current position already has a collision type of state (=overlap)
				checked = check_intersection_border(obj_1.coords_theory, border, obj_1.radius)
				var distance_earlier = checked.distance

				var course_next = {}

				var course_left_obj_1_x = round_calc_general((1-obj_1.increment) * obj_1.course.x)
				var course_left_obj_1_y = round_calc_general((1-obj_1.increment) * obj_1.course.y)

				var incr_course_x = round_calc_general(obj_1.course.x * incr_steps)
				var incr_course_y = round_calc_general(obj_1.course.y * incr_steps)

				var course_increase_x = round_calc_general(incr_course_x)
				for (var steps=1;Math.abs(course_increase_x)<Math.abs(course_left_obj_1_x);steps++) {
					
					var course_increase_x = round_calc_general(steps * incr_course_x)
					var course_increase_y = round_calc_general(steps * incr_course_y)

					course_next.x = round_calc_general(obj_1.coords_theory.x + course_increase_x)
					course_next.y = round_calc_general(obj_1.coords_theory.y + course_increase_y)
					checked = check_intersection_border(course_next, border, obj_1.radius) 

					if (checked.distance>distance_earlier) {
						// TODO: this method may not be fullproof, especially with higher speeds
						// you can come up with scenario's where a collision should be
						// detected but isn't because of this.
						return result
					} else if (checked.collision) {

						var incr = steps * incr_steps
						var total_incr = check_round_incr(obj_1.increment + incr) 
						
						var result = {found: true, log: {incr: total_incr,
														 obj_1: obj_1,
														 obj_2: obj_2}
									 }	
						return result

					} 

					distance_earlier = checked.distance

				}
				
				// do with increment at 100%
				course_next.x = obj_1.next_coords_theory.x
				course_next.y = obj_1.next_coords_theory.y

				checked = check_intersection_border(course_next, border, obj_1.radius)
				if (checked.collision) {
						var result = {found: true, log: {incr: 1.00,
														 obj_1: obj_1,
														 obj_2: obj_2}
									 }	
						return result
				}	

				return result
			}


			function check_intersection_border(course_next, border, object_radius) {
		
				var d1_x = course_next.x - border.start.x
				var d1_y = course_next.y - border.start.y

				// get normal of border:
				// get vector of border
				var d2_x = border.end.x - border.start.x
				var d2_y = border.end.y - border.start.y

				// get border angle
				//		inv-tan(d2_x/d2_y)	
				var border_angle = Math.atan2(-d2_y, d2_x)

				// TODO: does not always turn to the correct side, but not a problem.
				// can go for absolute size of projection and see is and how far the
				// dot is within area, maybe also do that with projection.
				var dn_angle_x = Math.cos(border_angle+(-0.5*Math.PI))
				var dn_angle_y = Math.sin(border_angle+(-0.5*Math.PI))

				var d1_magnitude = (d1_x**2 + d1_y**2)**(1/2)	 
				var d2_magnitude = (d2_x**2 + d2_y**2)**(1/2)	

				var dn_x = d2_magnitude * dn_angle_x
				var dn_y = d2_magnitude * dn_angle_y

				// angle between two vectors, vector of dot and vector of border:
				// dot product
				var dp_12 = (d1_x * d2_x) + (d1_y * d2_y)
				var db_angle = Math.acos(dp_12 / (d1_magnitude * d2_magnitude) )

				// angle between normal of border and vector of dot
				var dv_angle = (-0.5*Math.PI) - db_angle

				// projection of vector of dot on the normal of border
				// which is the distance between dot (center) and border:
				var d_db = d1_magnitude * Math.cos(dv_angle) 

				var found = {}
				//found.collision = (Math.abs(d_db)<=object_radius)
				found.distance = Math.abs(d_db)

				if (found.distance<object_radius) {	
					found.collision = true
				} else {
					found.collision = false
				}

				return found
			}


			function find_collision_dots(obj_1, obj_2) {
				
				function determine_earliest_object() {
					
					if (obj_1.increment>obj_2.increment) {
						var obj_temp = obj_1
						obj_1 = obj_2
						obj_2 = obj_temp
					}
				}
				
				determine_earliest_object()
	
				var o1_incr_todo = round_calc_general(1-obj_1.increment)
				// var o2_incr_todo = 1-obj_2.increment

				var o1_behind_prop_total = round_calc_general(obj_2.increment - obj_1.increment) //o1_incr_todo-o2_incr_todo
				var o1_behind_proportion_of_todo = round_calc_general(o1_behind_prop_total / o1_incr_todo)
				
				var o1_starting_incr_new = obj_2.increment
				var o1_course_left_todo_x = round_calc_general(obj_1.course.x * (1-o1_starting_incr_new))

				var o1_course_steps_x = round_calc_general(obj_1.course.x * incr_steps)
				var o1_course_steps_y = round_calc_general(obj_1.course.y * incr_steps)
				var o2_course_steps_x = round_calc_general(obj_2.course.x * incr_steps)
				var o2_course_steps_y = round_calc_general(obj_2.course.y * incr_steps)

				var o1_course_timebump_x = round_calc_general(o1_behind_prop_total * obj_1.course.x) // o1_course_left_todo_x * o1_behind_proportion_of_todo 
				var o1_course_timebump_y = round_calc_general(o1_behind_prop_total * obj_1.course.y) // o1_course_left_todo_y * o1_behind_proportion_of_todo 

				//TODO: maximum size maybe half a pixel?
				//		minimum.... incr_steps/100?
				// maybe a maximum stepsize?
				// arbitrary rule:
				// var max_step_size = this.radius/2	
				
				//if (o1_course_steps_x>max_step_size 
				// || o1_course_steps_y>max_step_size
				// || o2_course_steps_x>max_step_size
				// || o2_course_steps_y>max_step_size) {
				//	
				//	// not yet implemented
				//}

				var o1_pos_x = undefined
				var o1_pos_y = undefined
                var o2_pos_x = undefined
                var o2_pos_y = undefined
				var o1_step_x = o1_course_steps_x
				var d_sq = undefined

				function collision_criteria(d_x, d_y, d_r) {
					// TODO: does not detect when one circle is completely inside another
					// which should never happen..
					d_sq = (d_x * d_x) + (d_y * d_y)
					if ( d_sq <= (d_r * d_r) ) {
						return true
					}

					return false
				}

				function step_collision_check(steps) {
					
					o1_step_x = round_calc_general(steps * o1_course_steps_x)

					o1_pos_x = (obj_1.coords_theory.x + o1_course_timebump_x + o1_step_x)
					o1_pos_y = (obj_1.coords_theory.y + o1_course_timebump_y + (steps*o1_course_steps_y))
					o2_pos_x = (obj_2.coords_theory.x + (steps*o2_course_steps_x))
					o2_pos_y = (obj_2.coords_theory.y + (steps*o2_course_steps_y))

					var d_x = round_calc_general(o2_pos_x - o1_pos_x)
					var d_y = round_calc_general(o2_pos_y - o1_pos_y)
					var d_r = round_calc_general(obj_1.radius + obj_2.radius)

					return collision_criteria(d_x, d_y, d_r)
				}
				
				function final_collision_check() {
					
					var d_x = round_calc_general(obj_2.next_coords_theory["x"] - obj_1.next_coords_theory["x"])
					var d_y = round_calc_general(obj_2.next_coords_theory["y"] - obj_1.next_coords_theory["y"])
					var d_r = round_calc_general(obj_1.radius + obj_2.radius)

					return collision_criteria(d_x, d_y, d_r)
				}

				function calculate_result_on_increment(steps) {
					
					var result_incr = steps*incr_steps
					var incr_total = check_round_incr(obj_2.increment + result_incr)

					return incr_total
				}

				function bind_results(found, result_increment=0) {
					if (debug) {
						if (result_increment<0) {
							// error
							debugger
						}
					}

					if (found) {
						return {found: true, log: {incr: result_increment,
												   obj_1: obj_1,
												   obj_2: obj_2}
							   }
					}

					return {found: false, log: undefined}
				}
				
				step_collision_check(0)

				var d_sq_earlier = d_sq
				var steps = 1
				var checked_collision = undefined
				while (Math.abs(o1_step_x)<Math.abs(o1_course_left_todo_x)) {
					steps++

					checked_collision = step_collision_check(steps)

					if (d_sq>=d_sq_earlier) {
						return bind_results(false)
					}
					if (checked_collision) {
				
						var result_increment = calculate_result_on_increment(steps)
						return bind_results(true, result_increment)
					}

					d_sq_earlier = d_sq


				}
				
				if (final_collision_check()) {

					return bind_results(true, 1.00)
				}

				return bind_results(false)

			} // end find_collision_dots function

			function write_collision(obj_1, obj_2, incr) {
				
				choose_new_course_calculation(obj_1, obj_2, incr)
				// obj_1.track_collision.manage_reset(obj_2)
				// obj_1.track_collision.setter(obj_1, obj_2)

				return
			}

			function choose_new_course_calculation(obj_1, obj_2, incr) {
				
				if (obj_1 instanceof Dot && obj_2 instanceof Dot) {
					get_set_new_course_two_dots(obj_1, obj_2, incr)	
					return
				}
			
				get_set_course_border(obj_1, obj_2, incr)	

				return
			}

			function get_set_course_border(obj_1, obj_2, incr) {
				
				if (obj_1 instanceof Dot) {
					var dot = obj_1
					var border = obj_2
				} else {
					var dot = obj_2
					var border = obj_1
				}

				// TODO: increment can be taken out
				var d_x = dot.course.x * incr
				var d_y = dot.course.y * incr

				var angle_old = Math.atan2(d_y, d_x)
				
				if (border.side=="left" || border.side=="right") {
					
					var angle_old = Math.atan2(-d_y, -d_x)

				}

				var direction_x_new = Math.cos(-angle_old)
				var direction_y_new = Math.sin(-angle_old)
				
				if (debug) {
					
					var check_x = Math.cos(angle_old)
					var check_y = Math.sin(angle_old)					

					var angle_new = Math.atan2(direction_y_new, direction_x_new)

				}

				//var x_y_prop = dot.course.x / dot.course.y
				//s_sq = x_sq + y_sq
				//s_sq = x_sq + (x/x_y_p)_sq
				//s_sq = (c*x)_sq + (c*x/x_y_p)_sq
				//s_sq = c_sq * (x_sq + (x/x_y_p)_sq)
				////sqrt(s_sq/c_sq) = x_sq + (x/x_y_p)_sq
				//c_sq = s_sq / (x_sq + (x/x_y_p)_sq)

				var x_y_prop = direction_x_new / direction_y_new
				var c_sq = dot.speed_per_loop * dot.speed_per_loop / ( (direction_x_new * direction_x_new) + ( (direction_x_new / x_y_prop) * (direction_x_new/x_y_prop) ) ) 
				var c = c_sq**(1/2)

				dot.course.x = round_calc_general(direction_x_new * c)
			    dot.course.y = round_calc_general(direction_y_new * c)	
				
				return
			}

			function get_set_new_course_two_dots(dot_1, dot_2, incr) {

				if (debug_coll) {
					//var debug_check_list = [4,5,6]
					//var check_list = []
					for (var cl=0;cl<debug_check_list.length;cl++) {
						var to_check = debug_check_list[cl]
						if (dot_1.id==to_check || dot_2.id==to_check) {
							debugger
							break
						}
					}
				}
				
				var dot_1_coll_x = dot_1.coords_theory["x"]
				var dot_1_coll_y = dot_1.coords_theory["y"]
				var dot_2_coll_x = dot_2.coords_theory["x"]
				var dot_2_coll_y = dot_2.coords_theory["y"]

				var x_diff = dot_2_coll_x - dot_1_coll_x 
				var y_diff = dot_2_coll_y - dot_1_coll_y				
				var angle_coll = Math.atan2(y_diff, x_diff)

				var angle_1 = Math.atan2(dot_1.course["y"], dot_1.course["x"])
				var angle_2 = Math.atan2(dot_2.course["y"], dot_2.course["x"])

				var vel_1 = dot_1.speed_per_loop
				var vel_2 = dot_2.speed_per_loop

				var mass_1 = Math.PI * Math.pow(dot_1.radius, 2)
				var mass_2 = Math.PI * Math.pow(dot_2.radius, 2)
				var mass_total = mass_1 + mass_2
				
				var equation_tail_end_1 = Math.cos(angle_coll+(Math.PI/2))
				var	equation_tail_end_2 = Math.sin(angle_coll+(Math.PI/2))

				var counter_1_p1 = vel_1 * Math.cos(angle_1-angle_coll)*(mass_1-mass_2)
				var	counter_1_p2 = 2*mass_2*vel_2*Math.cos(angle_2-angle_coll)
				var division_1 = (counter_1_p1+counter_1_p2) / mass_total 
				var equation_tail_middle_1 = vel_1*Math.sin(angle_1-angle_coll)
				var result_1_x = (division_1 * Math.cos(angle_coll)) + (equation_tail_middle_1*equation_tail_end_1)
				var result_1_y = (division_1 * Math.sin(angle_coll)) + (equation_tail_middle_1*equation_tail_end_2)

				var counter_2_p1 = vel_2 * Math.cos(angle_2-angle_coll)*(mass_2-mass_1)
				var counter_2_p2 = 2*mass_1*vel_1*Math.cos(angle_1-angle_coll)
				var division_2 = (counter_2_p1+counter_2_p2) / mass_total
				var equation_tail_middle_2 = vel_2*Math.sin(angle_2-angle_coll)
				var result_2_x = (division_2 * Math.cos(angle_coll)) + (equation_tail_middle_2*equation_tail_end_1)
				var result_2_y = (division_2 * Math.sin(angle_coll)) + (equation_tail_middle_2*equation_tail_end_2)
				
				dot_1.course["x"] = round_calc_general(result_1_x)
			    dot_1.course["y"] =	round_calc_general(result_1_y)
				dot_1.speed_per_loop = round_calc_general(Math.sqrt(Math.pow(result_1_x, 2) + Math.pow(result_1_y, 2)))
				dot_1.speed = round_calc_general(dot_1.speed_per_loop * (1/(main_loop_interval/1000)))

				dot_2.course["x"] = round_calc_general(result_2_x)
			    dot_2.course["y"] =	round_calc_general(result_2_y)
				dot_2.speed_per_loop = round_calc_general(Math.sqrt(Math.pow(result_2_x, 2) + Math.pow(result_2_y, 2)))
				dot_2.speed = round_calc_general(dot_2.speed_per_loop * (1/(main_loop_interval/1000)))
					
				//////////////////////
				// var kin_before = (0.5 * mass_1 * vel_1**2) + (0.5 * mass_2 * Math.pow(vel_2, 2))	
				// var kin_after = (0.5 * mass_1 * dot_1.speed_per_loop**2) + (0.5 * mass_2 * dot_2.speed_per_loop**2)

				//console.log("kin energy before | after \n" + kin_before + " | " + kin_after)

				//console.log("proportion d1 y/x | d2 y/x: " + (result_1_y/result_1_x) + " | " + (result_2_y/result_2_x)) 

				return
			}
			
			function sort_grid_positions(grid_positions) {
				// NOTE: insertion sort is performed here, because
				// it is the algorithm if choice when the array is
				// almost sorted.
				// NOTE: an addition could be added here for the
				// newly added dot, since this could be an outlier
				// that could slow the algorithm down. But that's
				// only necessary when you don't throw the list
				// away after every loop. Which they aren't. 
				// TODO: a good unit test seems easy to write for 
				// this.

				for (var i=1;i<grid_positions.length;i++) {
					for (var k=i;k>0;k--) {

						// next one is higher, swap
						if (grid_positions[k-1]["x"]>grid_positions[k]["x"]) {
							swap_in_list(grid_positions, k, k-1)
							continue
						} 
							
						if (grid_positions[k-1]["x"]==grid_positions[k]["x"]) {

							// next one has equal x, but higher y, swap
							if (grid_positions[k-1]["y"]>grid_positions[k]["y"]) {
								swap_in_list(grid_positions, k, k-1)								
								continue	
							}

							// next one has equal x and equal or lower y, went far enough
							break
						}

						// next x is lower, went far enough
						if (grid_positions[k-1]["x"]<grid_positions[k]["x"]) {
							break
						}
					}
				}
				return
			}

			function sort_collision_storage(collision_storage) {
				// TODO: untested
				for (var i=1;i<collision_storage.length;i++) {
					for (var k=i;k>0;k--) {
						if (collision_storage[k-1]["incr"]>collision_storage[k].incr) {
							swap_in_list(collision_storage, k, k-1)
							continue
						}
						break
					}
				}
				return
			}
			
			function swap_in_list(list, first, second) {
				// TODO: make this a callable function
				// from the array
				var temp = list[first]
				list[first] = list[second]
				list[second] = temp
			}

			function get_set_border_objects(border_objects) {

				var border_object_1 = {type: "line", start: {x: 1, y: 1}, 
													 end: {x: 1, y: 500},
													 // track_collision: new Track_collision,
													 side: "left"}
				var border_object_2 = {type: "line", start: {x: 1, y: 500}, 
													 end: {x: 500, y: 500},
													 // track_collision: new Track_collision,
													 side: "ceiling"}
				var border_object_3 = {type: "line", start: {x: 500, y: 500}, 
													 end: {x: 500, y: 1},
													 // track_collision: new Track_collision,
													 side: "right"}
				var border_object_4 = {type: "line", start: {x: 500, y: 1}, 
													 end: {x: 1, y: 1},
													 // track_collision: new Track_collision,
													 side: "bottom"}

				border_objects.push(border_object_1)
				border_objects.push(border_object_2)
				border_objects.push(border_object_3)
				border_objects.push(border_object_4)

				return
			}

			// horrible horrible horrible
			function set_border_positions(grid_border_positions, border_objects) {
				// TODO: this is some obvious messy stuff				
				get_grid_line_1(grid_border_positions, border_objects[0])
				get_grid_line_2(grid_border_positions, border_objects[1])
				get_grid_line_1(grid_border_positions, border_objects[2])
				get_grid_line_2(grid_border_positions, border_objects[3])

				return
			}

			function get_grid_line_1(grid_border_positions, line_object) {
				
				if (line_object.start.x<line_object.end.x) {
					var start = line_object.start
					var end = line_object.end
				} else if (line_object.start.x>line_object.end.x) {
					var start = line_object.end
					var end = line_object.start
				} else if (line_object.start.x==line_object.end.x) {

					if (line_object.start.y<line_object.end.y) {
						var start = line_object.start
						var end = line_object.end
					} else {
						var start = line_object.end
						var end = line_object.start
					}

				}

				var options = {left: 1, right: Math.ceil(end.x/section_size.x)}	

				// NOTE: this is just to keep it very very simple,
				// will have to deploy the grid function here.
				var grid_start = Math.ceil(start.y/section_size.y)
				var grid_end = Math.ceil(end.y/section_size.y)
				for (var gr=grid_start;gr<=grid_end;gr++) {
					grid_border_positions.push({type: "line",
												obj: line_object,
											   	x: options[line_object.side],
											   	y: gr})
				}		
				return
			}

			function get_grid_line_2(grid_border_positions, line_object) {
				
				if (line_object.start.x<line_object.end.x) {
					var start = line_object.start
					var end = line_object.end
				} else if (line_object.start.x>line_object.end.x) {
					var start = line_object.end
					var end = line_object.start
				} else if (line_object.start.x==line_object.end.x) {

					if (line_object.start.y<line_object.end.y) {
						var start = line_object.start
						var end = line_object.end
					} else {
						var start = line_object.end
						var end = line_object.start
					}

				}

				var options = {bottom: 1, ceiling: Math.ceil(500/section_size.y)}	

				// NOTE: this is just to keep it very very simple,
				// will have to deploy the grid function here.
				
				// skip first because that's already in the first one
				var grid_start = Math.ceil(start.x/section_size.x)
				var grid_end = Math.ceil(end.x/section_size.x)
				for (var gr=grid_start;gr<=grid_end;gr++) {
					grid_border_positions.push({type: "line",
											   obj: line_object,
											   x: gr,
											   y: options[line_object.side]})
				}		
				return
			}
			
			class Dot {
				constructor(id, dot_spot) {

					// logistical information
					this.id = id
					this.dot_spot = dot_spot 
					this.grid_spots = []
					// this.track_collision = new Track_collision
					this.next_coords_theory = {} 
					this.increment = 0					// 0 means hasn't moved yet this loop
					// dot shape information
					this.radius = 20

					// course information
					this.course = []
					this.speed = undefined				// in pixels/second
					this.speed_per_loop = undefined		// in pixels/loop
					this.coords = {}
					this.coords_theory = {}

					this.set_speed()
					this.set_course()
					this.create_dot()
				}
				
				set_speed() {
					this.speed = 800

					if (debug_coll) {
						if (this.id==1) {
							this.speed = 25
						} else if (this.id==2) {
							this.speed = 60
						} else if (this.id==3) {
							this.speed = 60
						} else if (this.id==4) {
							this.speed = 683
						} else if (this.id==5) {
							this.speed=1500
						} else if (this.id==6) {
							this.speed = 1500
						}
					}

					this.speed_per_loop = this.speed/(1/(main_loop_interval/1000))
					return
				}

				set_course() {
					// var x = Math.random()
					// var y = Math.random()
					
					// TODO: icw convert course this is a meaningless metric
					var x = .5
					var y = .6

					if (debug_coll) {
						if (this.id==1) {
							var x = .8
							var y = .2
						} else if (this.id==2) {
							var x = .79
							var y = .30
						} else if (this.id==3) {
							var x = .6
							var y = .77
						} else if (this.id==4) {
							var x = .5
							var y = .6
						} else if (this.id==5) {
							var x = .5
							var y = .65
						} else if (this.id==6) {
							var x = .8
							var y = .203
						}
					}

					this.course = this.convert_course(x, y)
					this.coords_theory = {x: round_calc_general(this.course["x"]+starting_point.x), y: round_calc_general(this.course["y"]+starting_point.y)}
					this.coords = {x: Math.round(this.coords_theory["x"]), y: Math.round(this.coords_theory["y"])}

					return
				}

				convert_course(x, y) {
					var c_sq = Math.pow(this.speed_per_loop, 2) / (Math.pow(x, 2) + Math.pow(y, 2))
					var c = Math.sqrt(c_sq)

					return {x: c*x, y: c*y}
				}

				create_dot() {
					var canvass = this.create_canvas()					
					var drawing  = canvass.getContext("2d")

					drawing.beginPath()
					drawing.arc(this.radius,this.radius,this.radius,0,2*Math.PI)
					drawing.fillStyle = "#000000"


					if (debug) {
						if (this.id==3) {
							drawing.fillStyle = "#AA0000"
						}
					}

					if (demo_mode) {
						if (this.id==3) {
							drawing.fillStyle = "#AA0000"	
						}
					}
					
					drawing.fill()
					
					if (debug) {

						var txt = this.id.toString()
						drawing.fillStyle = "red"	
						drawing.font = "bold 16px Arial"
						drawing.fillText(txt, this.radius, this.radius)
					}


					return
				}

				create_canvas() {

					var center = this.radius
					var dot_canvas = document.createElement('canvas')
                    
					dot_canvas.id = "dot_" + this.id
                    dot_canvas.className = "dot_holder"
                    dot_canvas.style.position = "absolute";
                    dot_canvas.style.text = this.id
                    dot_canvas.style.margin = -(center) + "px", 0, 0, -(center) + "px"
                    dot_canvas.style.left = this.coords["x"] + "px"
                    dot_canvas.style.top = this.coords["y"] + "px"
                    
                    dot_canvas.width = center*2
                    dot_canvas.height = center*2

                    // dot_canvas.style.background = "red";
                    document.getElementById("circle").appendChild(dot_canvas)

                    return dot_canvas
			
				}
				
				move() {
					var dot_canvas = document.getElementById("dot_" + this.id)	
					dot_canvas.style.left = this.coords["x"] + "px"
					dot_canvas.style.top = this.coords["y"] + "px"
					
					if (debug) {
						if (this.coords.x>500 
				         || this.coords.y>500
						 || this.coords.x<0 
						 || this.coords.y<0) {
							//console.log(this.coords.x + " | " + this.coords.y)
							

						}
					}

					return
				}

				set_coords() {
					this.coords_theory["x"] = this.next_coords_theory["x"] 
					this.coords_theory["y"] = this.next_coords_theory["y"]
					this.coords["x"] = Math.round(this.coords_theory["x"])
					this.coords["y"] = Math.round(this.coords_theory["y"])

					return
				}
			
				determine_next_coords() {
					// NOTE: this way course does not have to be used when 
					// storing the new current coords. So setting the new course
					// does not effect the current course.
					
					this.next_coords_theory["x"] = round_calc_general(this.coords_theory["x"] + this.course["x"])
					this.next_coords_theory["y"] = round_calc_general(this.coords_theory["y"] + this.course["y"])

					return
				}

				manage_sections_setting() {
					// TODO: this should not have to be cleared here
					// although, why not, after collision it could
					// be handy, but no, then clear it especially for
					// here
					this.grid_spots = []
					
					// start situation
					this.get_set_section(this.coords_theory)
					
					// for end situation
					this.get_set_section(this.next_coords_theory)
					
					// get square in grid from minimum and maximum 
					// position in start and end situation
					this.determine_all_sections()	

					return
				}
			
				determine_all_sections() {
					// TODO: only tested a crude happyflow
					var x_min = Infinity 
					var y_min = Infinity
					var x_max = -Infinity
					var y_max = -Infinity

					for (var p=0;p<this.grid_spots.length;p++) {

						if (this.grid_spots[p]["x"]<x_min) {
							x_min = this.grid_spots[p]["x"]	
						}
						if (this.grid_spots[p]["x"]>x_max) {
							x_max = this.grid_spots[p]["x"]
						}
						if (this.grid_spots[p]["y"]<y_min) {
							y_min = this.grid_spots[p]["y"]	
						}
						if (this.grid_spots[p]["y"]>y_max) {
							y_max = this.grid_spots[p]["y"]
						}

					}

					// this list is cleared and than reused					
					this.grid_spots = []

					for (var x=x_min;x<=x_max;x++) {
						for (var y=y_min;y<=y_max;y++) {
							this.grid_spots.push({type: "dot",
												  obj: this, 
												  x: x, 
												  y: y})
						}
					}
					return	
				}

				get_set_section(coords) {

					this.grid_spots.push(this.calc_section(coords["x"], 
														   coords["y"]))

					var pi_steps = (2*Math.PI) / circle_resolution
					for (var c_res=0;c_res<circle_resolution;c_res++) {
						
						// NOTE: cl stands for circle edge
						var x_ce = Math.cos(pi_steps*c_res) * this.radius
						var y_ce = Math.sin(pi_steps*c_res) * this.radius

						var grid_section_next = this.calc_section(coords["x"] + x_ce, 
																  coords["y"] + y_ce)
						
						this.grid_spots.push(grid_section_next)

					}

					return
				}

				calc_section(coord_x, coord_y) {
					var section_x = coord_x / section_size["x"]
					var section_y = coord_y / section_size["y"]
					
					var grid_section_x = Math.floor(section_x+1)
					var grid_section_y = Math.floor(section_y+1)
					
					return {x: grid_section_x, 
							y: grid_section_y}
				}

			} // end Dot class

			class Track_collision {
				// NOTE: Used to track only the last collision.
				// TODO: work here with super, extend and stuff?
				constructor() {
					this.set= false
					this.obj_1 = undefined
					this.obj_2 = undefined
				}

				setter(obj_1, obj_2) {

					this.obj_1 = obj_1
					this.obj_2 = obj_2
					this.set = true

					obj_2.track_collision = this

					return
				}
						
				manage_reset(other_obj) {

					if (this.set) {
						this.reset_clean()
					} 
					
					// if code directly code didn't reset other_dot
					// do the reset for that dot also.	
					if (other_obj.track_collision.set) {
						other_obj.track_collision.reset_clean()
					}

					return
				}
				
				reset_clean() {
					
					this.obj_1.track_collision = new Track_collision()
					this.obj_2.track_collision = new Track_collision()
				
					return	
				}

				check_previous(other_obj) {

					if (!this.set) {
						return false
					}
				
					if (this.obj_1==other_obj || this.obj_2==other_obj) {
						return true
					}

					return false
				}

			} // end Track_collision class

		</script>

	</head>


	<body>

		<div id="circle" style="position:relative;">
		
		<!--<div id="timer_div">0</div>//-->

		<!--
			<div id="timer_div" style="position:absolute; text-align:center; bottom:0; color:red;">0</div>
		//-->

		</div>
	</body>

</html>


