 <!DOCTYPE html>


<!--

	Dennis Zethof - Februari 2018

	v0.45

	NOTE: The main focus of this specific project is to get the 
	collision detection algorithm right, this is a test setup,
	and by all means not finished. It is not efficient enough,
	and not without bugs. However, right now you can run it
	for quite a while, and I've seen no dots leaving their box
	or overlap eachother (except on their spawning area in the 
	upper left corner, they overlap there at first). The goal is to 
	let the box be fully filled with dots until none can be added. 
	I have removed most of the comments because they would
	clutter the code and where not written to be read by others.	
	
	Algorithms: this code scans all the dots, determines if there 
	will be any collisions, performs the collision earliest in time, 
	reevaluates the new situation caused by the collision, then
	performs the next earliest collision, reevaluates etc.
	
	By default the amount of dots is set at 80, you can easily set
	"settings_maximum_dots" to about 150. Ofcourse that may not run 
	as smooth.

-->

<html>
	<head>
		<script src="https://cdn.anychart.com/js/latest/graphics.min.js"></script>

		<style>

			body {
				background: yellow;
				margin: 0 0 0 0;
			}

            #circle {
                position: absolute; 
                width: 500px;
                height: 500px;
				background: white;
            }

			#my_canvas {
				position: absolute; 
                width: 500px;
                height: 500px;
				background: white;
            }


			#timer_div {
				position: absolute;
				bottom: 0; 
			   	width: 100%; 
				text-align: center;
				color: red;
			}

		</style>


		<script type="text/javascript">
		
			// globals

			// set options/constants
			var main_loop_interval = 35				// in milliseconds
			var dots_per_second = 0.2
			var circle_resolution = 20				// 2pi/circle_res
			var starting_point = {x: 45, y: 45}

			var settings_decimals_increment = 9
			var settings_decimals_calculations = 8
			var settings_maximum_dots = 80

			var section_size = {x: 20, y: 20}		// in pixels
			var dots = []							// for debug purposes defined as global
			var grid_positions = []					// for debug purposes defined as global
			var collision_storage = []

			var demo_mode = true
			var debug_main_loop_counter = 0
			var whilecounter = 0	
			var debug = false						// general debug mode
			var debug_coll = false					// debug mode for setting up collision det
			var debug_check_list = []
			var debug_timer_tracker = 0
			var debug_timer = 4.50					// seconds
			var debug_timer_steps = 100			// miliseconds
			var debug_specific = false 
			var debug_showstoppers = false

            window.onload = function() { 
				var loops_before_new_dot = Math.round(dots_per_second/(main_loop_interval/1000))
							
				if (debug) {
					test_find_collision()
				}

				var loops_since_new_dot = loops_before_new_dot-1
				var new_dot_id = 0
				var border_objects = [] 
				var grid_border_positions = []
				get_set_border_objects(border_objects)
				set_border_positions(grid_border_positions, border_objects)
				
				if (debug) {
					var interval = setInterval(function() {
						debug_timer_tracker = (Math.round((debug_timer_tracker + (debug_timer_steps/1000)) * 10) / 10)
						var timer_string = debug_timer_tracker.toFixed(2)
						document.getElementById("timer_div").innerHTML = timer_string
					}, debug_timer_steps)
				}

				var main_loop = setInterval(function() {
					if (debug) {
						debug_main_loop_counter++
					}
					loops_since_new_dot++
					if (loops_since_new_dot==loops_before_new_dot && dots.length<settings_maximum_dots) {
						new_dot_id++
						var new_dot = new Dot(new_dot_id, dots.length)
						dots.push(new_dot)
						loops_since_new_dot = 0
					}	

					if (debug_specific) {
						if (dots.length<settings_maximum_dots) {
							return
						}
					}
      
					for (var d=0;d<dots.length;d++) {
						dots[d].determine_next_coords()
						dots[d].manage_sections_setting()
					}

					if (debug) {
						if (debug_main_loop_counter>1901) {

						}
					}

					grid_add_border_positions(grid_positions, grid_border_positions)
					grid_add_dot_positions(grid_positions, dots)
					grid_sort_positions(grid_positions)

					find_collisions(collision_storage, grid_positions)
					sort_collision_time(collision_storage)
					var processed_collisions = false
						
					while (!processed_collisions) {

						if (debug) {
							whilecounter++
							console.log("debug main counter" + debug_main_loop_counter)		
							console.log("whilecounter: " + whilecounter)
							
							if (debug_main_loop_counter>-1) {
								if (collision_storage.length>0) {
									console.log(collision_storage[0].obj_1.id + " | " + 
												collision_storage[0].obj_2.id + " | " + 
												collision_storage[0].incr)
									console.log("increments: " + collision_storage[0].obj_1.increment + 
														 " | " + collision_storage[0].obj_2.increment)


								}

							}
							if (whilecounter>30000) {

							}

						}
						
						processed_collisions = manage_collision(grid_positions, collision_storage)

					}

					for(var d=0; d<dots.length; d++) {
						dots[d].set_coords()
						dots[d].move()
						dots[d].increment = 0
					}

					if (debug_showstoppers) {
						test_overlap_all_dots(dots) 
					}

					whilecounter = 0
					grid_positions = []
					collision_storage = []

				}, main_loop_interval)
			
			}

			function test_overlap_all_dots(dots) {
				if (dots.length<settings_maximum_dots) {
					return
				}

				for(var d=0;d<dots.length-1;d++) {
					for(var dd=d+1;dd<dots.length;dd++) {
						var dx = (dots[dd].coords_theory.x - dots[d].coords_theory.x)**2
						var dy = (dots[dd].coords_theory.y - dots[d].coords_theory.y)**2
						var dist = (dx+dy)**(1/2)
						var dist_norm = dots[d].radius + dots[dd].radius
						if (dist<(dist_norm*.95)) {
							alert("shit has gone down:\n\n" +	
								  "        significant overlap of dots")
							debugger
						}
					}
				}
				return
			}

			function check_dots_going_outside(dot) {
				if (dot.coords.x>500-dot.radius 
				 || dot.coords.y>500-dot.radius
				 || dot.coords.x<0+dot.radius 
				 || dot.coords.y<0+dot.radius) {
					console.log(dot.coords.x + " | " + dot.coords.y)
					alert("shit has gone done:\n\n" +
						  "        dot is going outside of border")
					debugger
				}
				return
			}

			function check_overlap(dot_1, dot_2) {


				if (dot_1 instanceof Dot && dot_2 instanceof Dot) {
					var dx = round_calc_general(dot_1.coords_theory.x - dot_2.coords_theory.x)
					var dy = round_calc_general(dot_1.coords_theory.y - dot_2.coords_theory.y)
					var c = round_calc_general((round_calc_general(dx**2) + round_calc_general(dy**2))**(1/2))
					
					var min_distance = round_calc_general(dot_1.radius + dot_2.radius)
					if (c<(min_distance)) {

					}
				}

				return
			}

			function manage_collision(grid_positions, collision_storage) {

				if (collision_storage.length==0) {
					return true
				}
				
				var info = get_next_collision_info(collision_storage)
			
				if (debug) {
					if (info.obj_1==info.obj_2) {
						// somehow a collision between a dot and
						// itself would have been registered.
						// error..
						debugger
					}
				}

				process_collision(info)	
				process_objects(info) 
				process_grid_positions(grid_positions, info)
				process_collision_storage(collision_storage, grid_positions, info)

				if (debug) {
						check_overlap(info.obj_1, info.obj_2)
				}

				if (debug) {
					try {
						if ((info.obj_1.coords.x>480  || info.obj_1.coords.y>480) 
						 || (info.obj_2.coords.x>480  || info.obj_2.coords.y>480)) {
				//			
						}
					} catch (err) {

					}
				}
				
				return (collision_storage.length==0)
			}

			function process_collision_storage(collision_storage, grid_positions, info) {

				clean_collision_storage(collision_storage, info)
				find_collisions(collision_storage, grid_positions, info)
				sort_collision_time(collision_storage)

				return
			}

			function process_objects(info) {

				do_section_setting(info.obj_1)
				do_section_setting(info.obj_2)
				info["redo_list"] = create_redo_list(info.obj_1, info.obj_2)

				return
			}

			function process_grid_positions(grid_position, info) {
				
				remove_old_grid_positions(grid_positions, [info.obj_1, info.obj_2])
			
				// make sure only dots are entered in grid_positions	
				var dots_to_add = []
				select_dots(dots_to_add, info)

				grid_add_dot_positions(grid_positions, dots_to_add)
				grid_sort_positions(grid_positions)

				return
			}

			function select_dots(dots_to_add, info) {
	
				if (info.obj_1 instanceof Dot) {
					dots_to_add.push(info.obj_1)
				}
				
				if (info.obj_2 instanceof Dot) {
					dots_to_add.push(info.obj_2)
				}

				return
			}

			function do_section_setting(obj) {

				if (obj instanceof Dot) {
					obj.manage_sections_setting()
				}

				return
			}

			function process_collision(info) {
				// NOTE: this is a 1-2 between coords_theory and
				// next_coords_theory. This collision has been set
				// as next one so next coords will be used icw
				// the incr to set the new coord. The new course
				// will then be determined, incl. the tracking
				// of that collision, and then icw the new course
				// a new next coord will be determined icw the
				// remaining incr value.
				var [obj_1, obj_2, incr] = [info.obj_1, info.obj_2, info.incr]

				set_coll_coordinates(obj_1, incr)
				set_coll_coordinates(obj_2, incr)
				handle_object_movement(obj_1)
				handle_object_movement(obj_2)
				
				choose_new_course_calculation(obj_1, obj_2, incr) 

				set_next_coordinates(obj_1)		
				set_next_coordinates(obj_2)		

				return
			}

			function get_next_collision_info(collision_storage) {

				var info = collision_storage[0]
				info.redo_mode = true	

				return info	
			}

			function create_redo_list(obj_1, obj_2) {
				var redo_list = []
					
				if (obj_1 instanceof Dot) {
					var first = obj_1
					var second = obj_2
				} else if (obj_2 instanceof Dot) {
					var first = obj_2
					var second = undefined
				} else {
					// error..
					debugger
					return redo_list
				}

				for (var gp=0;gp<first.grid_spots.length;gp++) {
					redo_list.push(first.grid_spots[gp])
				}	
				
				if (second instanceof Dot) {
					var found = false
					for (var gp=0;gp<second.grid_spots.length;gp++) {
						found = false
						for (var rl=0;rl<redo_list.length;rl++) {
							if (second.grid_spots[gp]["x"]==redo_list[rl]["x"] 
							 && second.grid_spots[gp]["y"]==redo_list[rl]["y"]) {
								found = true
								break
							}
						}	

						if (!found) {
							redo_list.push(second.grid_spots[gp])
						}
					}
				}

				return redo_list
			}

			function clean_collision_storage(collision_storage, info) {


				var cl = 0
				while (cl<collision_storage.length) {
					var cl_st = collision_storage[cl]
					if (cl_st.obj_1 instanceof Dot && cl_st.obj_2 instanceof Dot) {
						if (cl_st.obj_1===info.obj_1 || cl_st.obj_1===info.obj_2) { 
							collision_storage.splice(cl, 1)
							continue
						} else if (cl_st.obj_2===info.obj_1 || cl_st.obj_2===info.obj_2) {
							collision_storage.splice(cl, 1)
							continue
						}	
					} else if (!(cl_st.obj_1 instanceof Dot)) {
						if (cl_st.obj_2===info.obj_1 || cl_st.obj_2===info.obj_2) {
							collision_storage.splice(cl, 1)
							continue
						}	
					} else if (!(cl_st.obj_2 instanceof Dot)) {
						if (cl_st.obj_1===info.obj_1 || cl_st.obj_1===info.obj_2) {
							collision_storage.splice(cl, 1)
							continue
						}
					}

					cl++	
				}
				return
			}

			function set_coll_coordinates(obj, incr) {

				if (obj instanceof Dot) {
					obj.coords_theory.x = round_calc_general(obj.coords_theory.x + (obj.course.x * (incr-obj.increment)))
					obj.coords_theory.y = round_calc_general(obj.coords_theory.y + (obj.course.y * (incr-obj.increment))) 

					obj.coords.x = Math.round(obj.coords_theory.x)
					obj.coords.y = Math.round(obj.coords_theory.y)

					obj.increment = incr
				}
					
				return	
			}

			function check_round_incr(incr) {

				return get_rounded_number(incr, settings_decimals_increment)
			}

			function round_calc_general(value) {
				
				return get_rounded_number(value, settings_decimals_calculations)
			}

			function get_rounded_number(value, decimals) {
				// NOTE: if number is smaller than 0.000001, js converts it
				// to scientific notation, which would make the rounding 
				// process crash.
				// NOTE: when value is >= 1000000000000 is also produces
				// NaN, don't know why though. This also: 999999999999.99999, 
				// because js rounds that up. (too many digits?), but this
				// number: -1.2246467991473532e-16, is fine to enter				
				
				if (value<.000001) {
					// NOTE: decimal buffer is to ensure this method does not
					// determine the actual rounding. The number specified
					// however is arbitrary.
					var decimal_buffer = 6
					value = Number(value).toFixed(decimals+decimal_buffer).replace(/\.?0+$/,"")
				} else if (value>=1000000000000) {
					console.log("Not yet implemented: error will occur, number was " +
								"larger than possible for current implementation of " +
								"determining decimals.\n" +
								"Calling console.trace() now: ")
					console.trace()
				}

				return Number(Math.round(value+"e"+decimals)+"e-"+decimals)
			}

			function handle_object_movement(obj) {

				if (obj instanceof Dot) {
					obj.move()
				}

				return
			}

			function set_next_coordinates(obj) {

				if (obj instanceof Dot) {
					obj.next_coords_theory["x"] = round_calc_general(obj.coords_theory["x"] + (obj.course["x"]*(1-obj.increment)))
					obj.next_coords_theory["y"] = round_calc_general(obj.coords_theory["y"] + (obj.course["y"]*(1-obj.increment)))
				}

				return
			}

			function grid_add_border_positions(grid_positions, grid_border_positions) {
				
				for (var gb=0;gb<grid_border_positions.length;gb++) {
					grid_positions.push(grid_border_positions[gb])
				}

				return
			}

			function grid_add_dot_positions(grid_positions, objects_to_add) {
				
				for (var d=0;d<objects_to_add.length;d++) {
					for (var gs=0;gs<objects_to_add[d].grid_spots.length;gs++) {
						grid_positions.push(objects_to_add[d].grid_spots[gs])
					}
				}

				return
			}

			function remove_old_grid_positions(grid_positions, objects) {
				
				var grid_obj = undefined
				var gp = 0
				var relevant_objects = []
				var found = false

				for (var ob=0;ob<objects.length;ob++) {
					if (objects[ob] instanceof Dot) {
						relevant_objects.push(objects[ob])	
					}
				}

				while (gp<grid_positions.length) {
					grid_obj = grid_positions[gp].obj
					found = false

					for (var ro=0;ro<relevant_objects.length;ro++) {
						if (grid_obj===relevant_objects[ro]) {
							found = true
							break						
						}
					}

					if (found) {
						grid_positions.splice(gp, 1)		
						continue
					}
					gp++
				}
				
				return
			}

			function find_collisions(collision_storage, grid_positions, redo_info={redo_mode: false}) {
				
				var checked_this_round = []
				for (var gp=0;gp<grid_positions.length-1;gp++) {
				
					if (redo_info["redo_mode"]) {
						var redo_position = check_redo_position(grid_positions[gp], redo_info["redo_list"])
					}
					
					if (debug) {
						if (debug_main_loop_counter==276) {
							if (grid_positions[gp]["x"]==13 && grid_positions[gp]["y"]==2) {

							}
						}
					}

					// find a double
					if (grid_positions[gp]["x"]==grid_positions[gp+1]["x"]
					 && grid_positions[gp]["y"]==grid_positions[gp+1]["y"]) {
						var store_section = {x: grid_positions[gp]["x"], 
											 y: grid_positions[gp]["y"], 
											 objects_present: [grid_positions[gp]["obj"], 
															   grid_positions[gp+1]["obj"]
															  ]
											}

						var grid_pos_different = find_all_other_doubles(store_section, grid_positions, gp+2)

						gp = grid_pos_different-1			  
						if (redo_info["redo_mode"]) {
							if (!redo_position) {
								continue
							}
						}

						if (debug) {
							var id = store_section.objects_present[0].id
							if (debug_main_loop_counter>351 && (id==4 || id==5)) {

							}
						}

						check_section(store_section, checked_this_round, collision_storage, redo_info)
					}
				}
				return
			}

			function check_redo_position(grid_pos, redo_list) {

				for (var rl=0;rl<redo_list.length;rl++) {
					if (grid_pos["x"]==redo_list[rl]["x"] 
					 && grid_pos["y"]==redo_list[rl]["y"]) {
						return true
					}
				}

				return false
			}

			function find_all_other_doubles(store_section, grid_positions, next) {

				for (var gp_2=next;gp_2<grid_positions.length;gp_2++) {
					if (grid_positions[gp_2]["x"]==store_section["x"] 
					 && grid_positions[gp_2]["y"]==store_section["y"]) {
						store_section["objects_present"].push(grid_positions[gp_2]["obj"])
						continue
					}
					break
				}
				return gp_2	
			}

			function check_section(store_section, checked_this_round, collision_storage, redo_info) {
				var obj_list = store_section["objects_present"]

				for (var dl=0;dl<obj_list.length-1;dl++) {
						
					if (redo_info["redo_mode"]) {
						var first_dot_unchanged = undefined
						var second_dot_unchanged = undefined

						if ((obj_list[dl] != redo_info.obj_1
						  && obj_list[dl] != redo_info.obj_2)) {
							first_dot_unchanged = true
						} else {
							first_dot_unchanged = false
						}
					}

					if (obj_list[dl].type=="line") {
						var first_dot_is_line = true
					} else {
						var first_dot_is_line = false
					}

					for (var dl_2=dl+1;dl_2<obj_list.length;dl_2++) {
						

						if (first_dot_is_line && obj_list[dl_2].type=="line") {
							continue
						}

						// TODO: untested
						if (already_checked_this_grid_cycle(checked_this_round, obj_list[dl], obj_list[dl_2])) {
						   continue
						}	   

						if (redo_info["redo_mode"]) {
							if ((obj_list[dl_2] != redo_info.obj_1
							  && obj_list[dl_2] != redo_info.obj_2)) {
								second_dot_unchanged = true
							} else {
								second_dot_unchanged = false
							}
							
							if (first_dot_unchanged && second_dot_unchanged) {
								continue
							}	

							if (obj_list[dl].increment==1 || obj_list[dl_2].increment==1) {
								continue
							}
						}
	
						var result = choose_collision_calculation(obj_list[dl], obj_list[dl_2])
						checked_this_round.push({obj_1: obj_list[dl], obj_2: obj_list[dl_2]})

						if (result.found) {
							check_add_result(collision_storage, result.log)
						}
					}
				}
				return
			}

			function already_checked_this_grid_cycle(checked_this_round, obj_1, obj_2) {
				for (var c=0;c<checked_this_round.length;c++) {

					if (checked_this_round[c].obj_1===obj_1 
					 || checked_this_round[c].obj_1===obj_2) {

						if (checked_this_round[c].obj_2===obj_1 
					     || checked_this_round[c].obj_2===obj_2) {
							return true
						}
					}
				}
				return false
			}

			function already_in_collision_storage(obj_1, obj_2, collision_storage) {
				for (var cs=0;cs<collision_storage.length;cs++) {
					if (collision_storage[cs].obj_1===obj_1 
					 || collision_storage[cs].obj_1===obj_2) {

						if (collision_storage[cs].obj_2===obj_1 
					     || collision_storage[cs].obj_2===obj_2) {
							return true
						}
					}
				}
				return false
			}

			function check_add_result(collision_storage, log) {
				
				// TODO: seems this whole thing can go, because is 
				// already done by "checked this round" list.
				for (var cs=0;cs<collision_storage.length;cs++) {

					if (collision_storage[cs].obj_1===log.obj_1 
					 || collision_storage[cs].obj_1===log.obj_2) {

						if (collision_storage[cs].obj_2===log.obj_1 
					     || collision_storage[cs].obj_2===log.obj_2) {
							return
						}
					}
				}
				collision_storage.push(log)
				return
			}

			function choose_collision_calculation(obj_1, obj_2) {
				if (obj_1 instanceof Dot && obj_2 instanceof Dot) {
					var result = find_collision_dots_5(obj_1, obj_2)
				} else {
					var result = find_collision_border_2(obj_1, obj_2)
				}
				
				return result	
			}

			function test_find_collision () {
				// NOTE: for debug mode

				var dot_1 = {coords_theory: {}, course: {}}	
				var dot_2 = {coords_theory: {}, course: {}}	

				dot_1.coords_theory.x = 0
				dot_1.coords_theory.y = 4	
				dot_1.course.x = 1
				dot_1.course.y = -(1/3) 
				dot_1.radius = 0.5
				dot_1.increment = 0

				dot_2.coords_theory.x = 0
				dot_2.coords_theory.y = -1	
				dot_2.course.x = 1
				dot_2.course.y = 1
				dot_2.radius = 0.5
				dot_2.increment = 0

				find_collision_dots_5(dot_1, dot_2)

				dot_1.coords_theory.x = 1
				dot_1.coords_theory.y = 4	
				dot_1.course.x = 4
				dot_1.course.y = 2 
				dot_1.radius = 0.5
				dot_1.increment = 0

				dot_2.coords_theory.x = 3.5
				dot_2.coords_theory.y = 1	
				dot_2.course.x = -1
				dot_2.course.y = 6
				dot_2.radius = 0.5
				dot_2.increment = 0

				find_collision_dots_5(dot_1, dot_2)
				
				dot_1.coords_theory.x = 1
				dot_1.coords_theory.y = 6	
				dot_1.course.x = 4
				dot_1.course.y = -2 
				dot_1.radius = 0.5
				dot_1.increment = 0

				dot_2.coords_theory.x = 2.5 
				dot_2.coords_theory.y = 1	
				dot_2.course.x = 1
				dot_2.course.y = 6
				dot_2.radius = 0.5
				dot_2.increment = 0

				find_collision_dots_5(dot_1, dot_2)

			}

			function check_a_result(dot_1, dot_2, pt) {
				// NOTE: for debug mode

				var xn1 = dot_1.coords_theory.x + dot_1.course.x * pt
				var yn1 = dot_1.coords_theory.y + dot_1.course.y * pt
				var xn2 = dot_2.coords_theory.x + dot_2.course.x * pt
				var yn2 = dot_2.coords_theory.y + dot_2.course.y * pt

				var diff = round_calc_general((round_calc_general((xn1-xn2)**2) + round_calc_general((yn1-yn2)**2))**(1/2))
				var required = dot_1.radius + dot_2.radius	
				console.log("diff: " + diff)
				console.log("required: " + required)

				return
			}

			function find_collision_dots_5(dot_1, dot_2) {
				
				if (debug) {

					function print_stuff(dot) {
						console.log("dot_id: " + dot.id + "\n" +
									"d1 course x: " + dot.course.x + "\n" +
									"d1 course y: " + dot.course.y + "\n" 
									)	
					}

					if ((dot_1.id==2 && dot_2.id==5) || (dot_1.id==5 && dot_2.id==2)) {
						if (debug_main_loop_counter>4227) {
							print_stuff(dot_1)
							print_stuff(dot_2)

						}
					}

					if (dot_1.course.y==0 || dot_2.course.y==0) {
						debugger
					}
				}

				function determine_earliest_object() {
					if (dot_1.increment>dot_2.increment) {
						var dot_temp = dot_1
						dot_1 = dot_2
						dot_2 = dot_temp
					}
				}
				
				determine_earliest_object()

				var incr_diff = check_round_incr(dot_2.increment - dot_1.increment)
				var dot_1_bump_x = round_calc_general(dot_1.course.x * incr_diff)
				var dot_1_bump_y = round_calc_general(dot_1.course.y * incr_diff)
				var dot_1_x = round_calc_general(dot_1.coords_theory.x + dot_1_bump_x)
				var dot_1_y = round_calc_general(dot_1.coords_theory.y + dot_1_bump_y)
				
				var k1a = round_calc_general(dot_1_x**2 + dot_2.coords_theory.x**2) 
				var k1b = round_calc_general(-2 * dot_1_x * dot_2.coords_theory.x)
				var k1 = round_calc_general(k1a + k1b)
				var w1 = round_calc_general(dot_1.course.x - dot_2.course.x)
				var q1a = round_calc_general(2 * dot_1_x * w1)
				var q1b = round_calc_general(2 * dot_2.coords_theory.x * w1)
				var q1 = round_calc_general(q1a - q1b)

				var k2a = round_calc_general(dot_1_y**2 + dot_2.coords_theory.y**2) 
				var k2b = round_calc_general(-2 * dot_1_y * dot_2.coords_theory.y)
				var k2 = round_calc_general(k2a + k2b)
				var w2 = round_calc_general(dot_1.course.y - dot_2.course.y)
				var q2a = round_calc_general(2 * dot_1_y * w2) 
				var q2b = round_calc_general(2 * dot_2.coords_theory.y * w2)
				var q2 = round_calc_general(q2a - q2b)

				var c_sq = round_calc_general((round_calc_general(dot_1.radius + dot_2.radius))**2)

				var wt = round_calc_general(w1**2 + w2**2)
				var qt = round_calc_general(q1 + q2)
				var kt = round_calc_general(k1 + k2 - c_sq)

				// abc formula:
				var a = wt
				var b = qt
				var c = kt

				if (debug) {
					if (a==0) {
						// error...
						console.log("error: a==0")
						debugger
					}
				}
				
				// discriminant of kwadratic formula	
				var d = round_calc_general(b**2 - (4 * a * c))

				if (d<0) {
					return {found: false, log: undefined}
				}
				
				var d_sqrt = round_calc_general(d**(1/2))
				var a2 = 2 * a
				var pt_1 = check_round_incr((-b + d_sqrt) / a2) 
				var pt_2 = check_round_incr((-b - d_sqrt) / a2) 

				if (debug) {
					if (false) {
						console.log("-------")
						console.log("should be fine: " + pt_1 + " | " + pt_2)
						console.log("discriminant: " + d)

						console.log("   check results 1... ")
						check_a_result(dot_1, dot_2, pt_1)
						console.log("   check results 2... ")
						check_a_result(dot_1, dot_2, pt_2)
					}
				}

				function check_validity(pt_1, pt_2, max_increment) {
				
					// means they would go in the wrong direction for
					// them to be in a collision. Most likely they were
					// just in a collision, OR there was just some
					// overlap due to rounding
					if (pt_1 < 0 || pt_2 < 0) {
						return [false, false]
					}

					var first_valid = second_valid = false
				
					// first part of if statement is important when two collisions 
					// takes place at the same increment	
					if (pt_1 >= 0 && pt_1 <= max_increment) {
						first_valid = true
					}
					
					if (pt_2 >= 0 && pt_2 <= max_increment) {
						second_valid = true
					}

					return [first_valid, second_valid]
				}
				
				var max_increment = check_round_incr(1-dot_2.increment)	
				var [first_valid, second_valid] = check_validity(pt_1, pt_2, max_increment)

				if (first_valid && second_valid) {
					var pt = Math.min(pt_1, pt_2)
				} else if (first_valid) {
					var pt = pt_1
				} else if (second_valid) {
					var pt = pt_2
				} else {
					return {found: false, log: undefined}
				}

				var incr_total = check_round_incr(dot_2.increment + pt)
				var result = {found: true, log: {incr: incr_total,
												 obj_1: dot_1,
												 obj_2: dot_2}
							 }

				if (debug) {
					if (incr_total>1) {
						//error..
						debugger
					}
				}
				return result
			} 

			function find_collision_border_2(obj_1, obj_2) {

				var dot, border

				if (obj_1 instanceof Dot) {
					dot = obj_1
					border = obj_2	
				} else {
					dot = obj_2
					border = obj_1
				}
				
				var border_normal = {}
				border_normal.x = round_calc_general(border.end.y - border.start.y)
				border_normal.y = round_calc_general(border.end.x - border.start.x)
				
				border_normal.length = (border_normal.x**2 + border_normal.y**2)**(1/2)
				
				border_normal.unit_x = border_normal.x / border_normal.length
				border_normal.unit_y = border_normal.y / border_normal.length

				// projection of starting position
				var dot_origin_border_x = round_calc_general(dot.coords_theory.x - border.start.x)
				var dot_origin_border_y = round_calc_general(dot.coords_theory.y - border.start.y)
				var proj_starting_pos_a = round_calc_general(dot_origin_border_x * border_normal.unit_x) 
				var proj_starting_pos_b = round_calc_general(dot_origin_border_y * border_normal.unit_y)
				var proj_starting_pos = round_calc_general(proj_starting_pos_a + proj_starting_pos_b)
	
				var c = dot.radius

				if (proj_starting_pos < 0) {
					c = -c
				}
				
				if (debug) {
					if (dot.course.x==0 || dot.course.y==0) {
						debugger
					}
				}

				var k1 = round_calc_general((dot.coords_theory.x) * border_normal.unit_x) 
				var k2 = round_calc_general((dot.coords_theory.y) * border_normal.unit_y) 
				var k3 = round_calc_general(-border.start.x * border_normal.unit_x)
				var k4 = round_calc_general(-border.start.y * border_normal.unit_y)
				var k = round_calc_general(k1 + k2 + k3 + k4) 
				var u1 = round_calc_general(dot.course.x * border_normal.unit_x)
				var u2 = round_calc_general(dot.course.y * border_normal.unit_y)
				var u = round_calc_general(u1 + u2)

				var k_coll = round_calc_general(k - c)
				var k_after = round_calc_general(k + c)
				
				if (debug) {
					if (u==0) {
						debugger
					}
				}

				var pt = check_round_incr(-k_coll/u)
				var pt_after = check_round_incr(-k_after/u)

				function check_validity(pt, pt_after, max_increment) {
					if (pt > pt_after) {
						return false
					}
					
					if (debug) {
						if (pt==pt_after) {
							// error..?
							debugger
						}
					}

					//pt < 0 = bad
					//pt_after< 0 = bad
					if (pt < 0 || pt_after < 0) {
						return false
					}

					//pt <= max_increment = good
					if (pt > max_increment) {
						return false
					}

					return true
				}
				
				var max_increment = check_round_incr(1-dot.increment)	
				if (!check_validity(pt, pt_after, max_increment)) {
					return {found: false, log: undefined}
				}

				var incr_total = check_round_incr(dot.increment + pt)
				var result = {found: true, log: {incr: incr_total,
												 obj_1: dot,
												 obj_2: border}
							 }

				if (debug) {
					if (incr_total>1) {
						debugger
					}
				}
				return result
			} 

			function find_collision_dots_2(dot_1, dot_2) {

				if (dot_1.increment>dot_2.increment) {
					var dot_temp = dot_1
					dot_1 = dot_2
					dot_2 = dot_temp
				}
				
				// TODO: test box corners with sin/cos/tan
				var box_1 = create_box_dot(dot_1)	
				var box_2 = create_box_dot(dot_2)	

				var result = doPolygonsIntersect(box_1, box_2) 
		
				var c = document.getElementById("my_canvas");
				var ctx = c.getContext("2d");
				ctx.moveTo(box_1[0].x,box_1[0].y);
				ctx.lineTo(box_1[1].x,box_1[1].y);
				ctx.lineTo(box_1[2].x,box_1[2].y);
				ctx.lineTo(box_1[3].x,box_1[3].y);
				ctx.lineTo(box_1[0].x,box_1[0].y);
				ctx.stroke();

				ctx.moveTo(box_2[0].x,box_2[0].y);
				ctx.lineTo(box_2[1].x,box_2[1].y);
				ctx.lineTo(box_2[2].x,box_2[2].y);
				ctx.lineTo(box_2[3].x,box_2[3].y);
				ctx.lineTo(box_2[0].x,box_2[0].y);
				ctx.stroke();
			}

			/**
			* Helper function to determine whether there is an intersection between the two polygons described
			* by the lists of vertices. Uses the Separating Axis Theorem
			*
			* @param a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
			* @param b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon
			* @return true if there is any intersection between the 2 polygons, false otherwise
			*/
			function doPolygonsIntersect (a, b, dot_1, dot_2) {
				// TODO: refactor names
				// TODO: can be done  more efficiently for rectangles, since they are parallel
				var polygons = [a, b];
				var minA, maxA, projected, i, i1, j, minB, maxB, min_edge;

				for (i = 0; i < polygons.length; i++) {

					// for each polygon, look at each edge of the polygon, and determine if it separates
					// the two shapes
					var polygon = polygons[i];
					for (i1 = 0; i1 < polygon.length; i1++) {
						
						// no need to check an edge between
						// nodes of a and b
						// TODO: check if this addition is correct
						if (i1==a.length-1) {
							continue
						}

						// grab 2 vertices to create an edge
						var i2 = (i1 + 1) % polygon.length;
						var p1 = polygon[i1];
						var p2 = polygon[i2];

						// find the line perpendicular to this edge
						var normal = { x: p2.y - p1.y, y: p1.x - p2.x };

						minA = maxA = undefined;
						// for each vertex in the first shape, project it 
						// onto the line perpendicular to the edge
						// and keep track of the min and max of these values
						for (j = 0; j < a.length; j++) {
							projected = normal.x * a[j].x + normal.y * a[j].y;
							if (minA==undefined || projected < minA) {
								minA = projected;
							}	
							if (maxA==undefined || projected > maxA) {
								maxA = projected;
							}
						}

						// for each vertex in the second shape, project it 
						// onto the line perpendicular to the edge
						// and keep track of the min and max of these values
						minB = maxB = undefined;
						for (j = 0; j < b.length; j++) {
							projected = normal.x * b[j].x + normal.y * b[j].y;
							if (minB==undefined || projected < minB) {
									minB = projected;
							}
							if (maxB==undefined || projected > maxB) {
								maxB = projected;
							}
						}

						// if there is no overlap between the projects, the 
						// edge we are looking at separates the two
						// polygons, and we know there is no overlap
						if (maxA < minB || maxB < minA) {
							CONSOLE("polygons don't intersect!");
							return false;
						}

						function get_interval_distance(min_a, max_a, min_b, max_b) {
							if (min_a<min_b) {
								return max_a-min_b
							} else {
								return max_b-min_a
							}
						}
						
						result_interval_distance = get_interval_distance(minA, maxA, minB, maxB)
						if (result_interval_distance<min_interval_distance) {
							min_interval_distance = result_interval_distance
							min_edge = normal
						}	
						
						var dx = dot_1.coords_theory.x - dot_2.coords_theory.x
						var dy = dot_1.coords_theory.y - dot_2.coords_theory.y

						projected = dx * min_edge.x + dy * min_edge.y

						if (projected<0) {
							normal.x = -normal.x
							normal.y = -normal.y
						}
					}
				}
				return true;
			};




			function create_box_dot(dot) {
				
				var course_angle = Math.atan2(dot.course.y, dot.course.x)

				var offset_side_1 = get_offset_dimensions_dot(dot, course_angle+0.5*Math.PI)
				var offset_side_2 = get_offset_dimensions_dot(dot, course_angle-0.5*Math.PI)
				
				var offset_vector = get_offset_dimensions_dot(dot, course_angle)
	
				var start_center_x = dot.coords_theory.x - offset_vector.x 
				var start_center_y = dot.coords_theory.y - offset_vector.y

				var end_center_x = dot.next_coords_theory.x + offset_vector.x	
				var end_center_y = dot.next_coords_theory.y + offset_vector.y	

				var corners = []
				for (var c=0;c<4;c++) {
					corners.push({})
				}

				corners[0].x = start_center_x + offset_side_1.x	
				corners[0].y = start_center_y + offset_side_1.y	
				corners[1].x = start_center_x + offset_side_2.x	
				corners[1].y = start_center_y + offset_side_2.y	
				
				corners[2].x = end_center_x + offset_side_2.x	
				corners[2].y = end_center_y + offset_side_2.y	
				corners[3].x = end_center_x + offset_side_1.x	
				corners[3].y = end_center_y + offset_side_1.y	

				return corners	
			}

			function get_offset_dimensions_dot(dot, new_angle) {
				// TODO: dots may neve change shape, then this only has to be calculated once.
				
				var angle_new_x = Math.cos(new_angle)
				var angle_new_y = Math.sin(new_angle)
				
				var offset_x = angle_new_x * dot.radius
				var offset_y = angle_new_y * dot.radius

				return {x: offset_x, y: offset_y}
			}	

			function choose_new_course_calculation(obj_1, obj_2, incr) {
				
				if (obj_1 instanceof Dot && obj_2 instanceof Dot) {
					get_set_new_course_two_dots(obj_1, obj_2, incr)	
					return
				}
			
				get_set_course_border(obj_1, obj_2, incr)	

				return
			}

			function get_set_course_border(obj_1, obj_2, incr) {
				
				if (obj_1 instanceof Dot) {
					var dot = obj_1
					var border = obj_2
				} else {
					var dot = obj_2
					var border = obj_1
				}

				if (debug) {
					if (dot.id==10 && debug_main_loop_counter>704) {

					}
				}	

				var d_x = dot.course.x * incr
				var d_y = dot.course.y * incr

				var angle_old = Math.atan2(d_y, d_x)
				
				if (border.side=="left" || border.side=="right") {
					
					//angle_old = Math.PI - angle_old	

					var angle_old = Math.atan2(-d_y, -d_x)

				}

				var direction_x_new = Math.cos(-angle_old)
				var direction_y_new = Math.sin(-angle_old)
				
				if (debug) {
					
					var check_x = Math.cos(angle_old)
					var check_y = Math.sin(angle_old)					

					var angle_new = Math.atan2(direction_y_new, direction_x_new)

				}

				var x_y_prop = direction_x_new / direction_y_new
				var c_sq = dot.speed_per_loop * dot.speed_per_loop / ( (direction_x_new * direction_x_new) + ( (direction_x_new / x_y_prop) * (direction_x_new/x_y_prop) ) ) 
				var c = c_sq**(1/2)

				if (debug) {
					if (direction_x_new==0 || direction_y_new==0 || c==0) {
						debugger
					} 
					var test_x = round_calc_general(direction_x_new * c)
					var test_y = round_calc_general(direction_y_new * c)

					if (test_x==0 || test_y==0) {
						debugger
					}

				}
				
				dot.course.x = round_calc_general(direction_x_new * c)
			    dot.course.y = round_calc_general(direction_y_new * c)	
				
				return
			}

			function get_set_new_course_two_dots(dot_1, dot_2, incr) {

				if (debug_coll) {
					for (var cl=0;cl<debug_check_list.length;cl++) {
						var to_check = debug_check_list[cl]
						if (dot_1.id==to_check || dot_2.id==to_check) {

							break
						}
					}
				}
				
				var dot_1_coll_x = dot_1.coords_theory["x"]
				var dot_1_coll_y = dot_1.coords_theory["y"]
				var dot_2_coll_x = dot_2.coords_theory["x"]
				var dot_2_coll_y = dot_2.coords_theory["y"]
				
				var x_diff = dot_2_coll_x - dot_1_coll_x 
				var y_diff = dot_2_coll_y - dot_1_coll_y				
				var angle_coll = Math.atan2(y_diff, x_diff)

				var angle_1 = Math.atan2(dot_1.course["y"], dot_1.course["x"])
				var angle_2 = Math.atan2(dot_2.course["y"], dot_2.course["x"])

				var vel_1 = dot_1.speed_per_loop
				var vel_2 = dot_2.speed_per_loop

				var mass_1 = Math.PI * Math.pow(dot_1.radius, 2)
				var mass_2 = Math.PI * Math.pow(dot_2.radius, 2)
				var mass_total = mass_1 + mass_2
				
				var equation_tail_end_1 = Math.cos(angle_coll+(Math.PI/2))
				var	equation_tail_end_2 = Math.sin(angle_coll+(Math.PI/2))

				var counter_1_p1 = vel_1 * Math.cos(angle_1-angle_coll)*(mass_1-mass_2)
				var	counter_1_p2 = 2*mass_2*vel_2*Math.cos(angle_2-angle_coll)
				var division_1 = (counter_1_p1+counter_1_p2) / mass_total 
				var equation_tail_middle_1 = vel_1*Math.sin(angle_1-angle_coll)
				var result_1_x = (division_1 * Math.cos(angle_coll)) + (equation_tail_middle_1*equation_tail_end_1)
				var result_1_y = (division_1 * Math.sin(angle_coll)) + (equation_tail_middle_1*equation_tail_end_2)

				var counter_2_p1 = vel_2 * Math.cos(angle_2-angle_coll)*(mass_2-mass_1)
				var counter_2_p2 = 2*mass_1*vel_1*Math.cos(angle_1-angle_coll)
				var division_2 = (counter_2_p1+counter_2_p2) / mass_total
				var equation_tail_middle_2 = vel_2*Math.sin(angle_2-angle_coll)
				var result_2_x = (division_2 * Math.cos(angle_coll)) + (equation_tail_middle_2*equation_tail_end_1)
				var result_2_y = (division_2 * Math.sin(angle_coll)) + (equation_tail_middle_2*equation_tail_end_2)
				
				dot_1.course["x"] = round_calc_general(result_1_x)
			    dot_1.course["y"] =	round_calc_general(result_1_y)
				dot_1.speed_per_loop = round_calc_general(Math.sqrt(Math.pow(result_1_x, 2) + Math.pow(result_1_y, 2)))
				dot_1.speed = round_calc_general(dot_1.speed_per_loop * (1/(main_loop_interval/1000)))

				dot_2.course["x"] = round_calc_general(result_2_x)
			    dot_2.course["y"] =	round_calc_general(result_2_y)
				dot_2.speed_per_loop = round_calc_general(Math.sqrt(Math.pow(result_2_x, 2) + Math.pow(result_2_y, 2)))
				dot_2.speed = round_calc_general(dot_2.speed_per_loop * (1/(main_loop_interval/1000)))
					
				return
			}
			
			function grid_sort_positions(grid_positions) {
				// NOTE: insertion sort is performed here, because
				// it is the algorithm of choice when the array is
				// almost sorted.

				for (var i=1;i<grid_positions.length;i++) {
					for (var k=i;k>0;k--) {

						// next one is higher, swap
						if (grid_positions[k-1]["x"]>grid_positions[k]["x"]) {
							swap_in_list(grid_positions, k, k-1)
							continue
						} 
							
						if (grid_positions[k-1]["x"]==grid_positions[k]["x"]) {

							// next one has equal x, but higher y, swap
							if (grid_positions[k-1]["y"]>grid_positions[k]["y"]) {
								swap_in_list(grid_positions, k, k-1)								
								continue	
							}

							// next one has equal x and equal or lower y, went far enough
							break
						}

						// next x is lower, went far enough
						if (grid_positions[k-1]["x"]<grid_positions[k]["x"]) {
							break
						}
					}
				}
				return
			}

			function sort_collision_time(collision_storage) {
				for (var i=1;i<collision_storage.length;i++) {
					for (var k=i;k>0;k--) {
						if (collision_storage[k-1]["incr"]>collision_storage[k].incr) {
							swap_in_list(collision_storage, k, k-1)
							continue
						}
						break
					}
				}
				return
			}
			
			function swap_in_list(list, first, second) {
				var temp = list[first]
				list[first] = list[second]
				list[second] = temp
			}

			function get_set_border_objects(border_objects) {

				var border_object_1 = {type: "line", start: {x: 1, y: 1}, 
													 end: {x: 1, y: 500},
													 // track_collision: new Track_collision,
													 side: "left"}
				var border_object_2 = {type: "line", start: {x: 1, y: 500}, 
													 end: {x: 500, y: 500},
													 // track_collision: new Track_collision,
													 side: "ceiling"}
				var border_object_3 = {type: "line", start: {x: 500, y: 500}, 
													 end: {x: 500, y: 1},
													 // track_collision: new Track_collision,
													 side: "right"}
				var border_object_4 = {type: "line", start: {x: 500, y: 1}, 
													 end: {x: 1, y: 1},
													 // track_collision: new Track_collision,
													 side: "bottom"}

				border_objects.push(border_object_1)
				border_objects.push(border_object_2)
				border_objects.push(border_object_3)
				border_objects.push(border_object_4)

				return
			}

			function set_border_positions(grid_border_positions, border_objects) {
				get_grid_line_1(grid_border_positions, border_objects[0])
				get_grid_line_2(grid_border_positions, border_objects[1])
				get_grid_line_1(grid_border_positions, border_objects[2])
				get_grid_line_2(grid_border_positions, border_objects[3])

				return
			}

			function get_grid_line_1(grid_border_positions, line_object) {
				
				if (line_object.start.x<line_object.end.x) {
					var start = line_object.start
					var end = line_object.end
				} else if (line_object.start.x>line_object.end.x) {
					var start = line_object.end
					var end = line_object.start
				} else if (line_object.start.x==line_object.end.x) {

					if (line_object.start.y<line_object.end.y) {
						var start = line_object.start
						var end = line_object.end
					} else {
						var start = line_object.end
						var end = line_object.start
					}

				}

				var options = {left: 1, right: Math.ceil(end.x/section_size.x)}	

				var grid_start = Math.ceil(start.y/section_size.y)
				var grid_end = Math.ceil(end.y/section_size.y)
				for (var gr=grid_start;gr<=grid_end;gr++) {
					grid_border_positions.push({type: "line",
												obj: line_object,
											   	x: options[line_object.side],
											   	y: gr})
				}		
				return
			}

			function get_grid_line_2(grid_border_positions, line_object) {
				
				if (line_object.start.x<line_object.end.x) {
					var start = line_object.start
					var end = line_object.end
				} else if (line_object.start.x>line_object.end.x) {
					var start = line_object.end
					var end = line_object.start
				} else if (line_object.start.x==line_object.end.x) {

					if (line_object.start.y<line_object.end.y) {
						var start = line_object.start
						var end = line_object.end
					} else {
						var start = line_object.end
						var end = line_object.start
					}

				}

				var options = {bottom: 1, ceiling: Math.ceil(500/section_size.y)}	
				var grid_start = Math.ceil(start.x/section_size.x)
				var grid_end = Math.ceil(end.x/section_size.x)
				for (var gr=grid_start;gr<=grid_end;gr++) {
					grid_border_positions.push({type: "line",
											   obj: line_object,
											   x: gr,
											   y: options[line_object.side]})
				}		
				return
			}
			
			class Dot {
				constructor(id, dot_spot) {

					// logistical information
					this.id = id
					this.dot_spot = dot_spot 
					this.grid_spots = []
					this.next_coords_theory = {} 
					this.increment = 0					// 0 means hasn't moved yet this loop
					// dot shape information
					this.radius = 20

					// course information
					this.course = []
					this.speed = undefined				// in pixels/second
					this.speed_per_loop = undefined		// in pixels/loop
					this.coords = {}
					this.coords_theory = {}

					this.set_speed()
					this.set_course()
					this.create_dot()
				}
				
				set_speed() {
					this.speed = 800

					if (debug_coll) {
						if (this.id==1) {
							this.speed = 925
						} else if (this.id==2) {
							this.speed = 660
						} else if (this.id==3) {
							this.speed = 360
						} else if (this.id==4) {
							this.speed = 683
						} else if (this.id==5) {
							this.speed=1500
						} else if (this.id==6) {
							this.speed = 1500
						}
					}

					this.speed_per_loop = round_calc_general(this.speed/(1/(main_loop_interval/1000)))
					return
				}

				set_course() {
					// var x = Math.random()
					// var y = Math.random()

					var x = .5
					var y = .6

					if (debug_coll) {
						if (this.id==1) {
							var x = .8
							var y = .2
						} else if (this.id==2) {
							var x = .79
							var y = .30
						} else if (this.id==3) {
							var x = .6
							var y = .77
						} else if (this.id==4) {
							var x = .5
							var y = .6
						} else if (this.id==5) {
							var x = .5
							var y = .65
						} else if (this.id==6) {
							var x = .8
							var y = .203
						}
					}

					this.course = this.convert_course(x, y)
					this.coords_theory = {x: round_calc_general(this.course["x"]+starting_point.x), 
										  y: round_calc_general(this.course["y"]+starting_point.y)}
					this.coords = {x: Math.round(this.coords_theory["x"]), y: Math.round(this.coords_theory["y"])}

					if (debug_specific) {
						if (this.id==1) {
							this.course = {x: 19.4562063, y: 0.77704052}
							this.coords_theory = {x: 462.75462212, y: 475.56497464}
							this.coords = {x: Math.round(this.coords_theory["x"]), 
										   y: Math.round(this.coords_theory["y"])}
							this.increment = 0.036 
							this.speed_per_loop = 19.47171681
						} else if (this.id==2) {
							this.course = {x: 36.30442919, y: 55.09223259}
							this.coords_theory = {x: 422.03802785, y: 454.94685177}
							this.coords = {x: Math.round(this.coords_theory["x"]), 
										   y: Math.round(this.coords_theory["y"])}
							this.increment = 0.426
							this.speed_per_loop = 65.97852431
						}
					}

					return
				}

				convert_course(x, y) {
					var c_sq = Math.pow(this.speed_per_loop, 2) / (Math.pow(x, 2) + Math.pow(y, 2))
					var c = round_calc_general(Math.sqrt(c_sq))

					return {x: round_calc_general(c*x), y: round_calc_general(c*y)}
				}

				create_dot() {
					var canvass = this.create_canvas()					
					var drawing  = canvass.getContext("2d")

					drawing.beginPath()
					drawing.arc(this.radius,this.radius,this.radius,0,2*Math.PI)
					drawing.fillStyle = "#000000"


					if (debug) {
						if (this.id==3) {
							drawing.fillStyle = "#AA0000"
						}
					}

					if (demo_mode) {
						if (this.id==3) {
							drawing.fillStyle = "#AA0000"	
						}
						if (this.id==4) {
							drawing.fillStyle = "#00AA00"	
						}
						if (this.id==5) {
							drawing.fillStyle = "#0000AA"	
						}
					}
					
					drawing.fill()
					
					if (debug) {

						var txt = this.id.toString()
						drawing.fillStyle = "red"	
						drawing.font = "bold 16px Arial"
						drawing.fillText(txt, this.radius, this.radius)
					}


					return
				}

				create_canvas() {

					var center = this.radius
					var dot_canvas = document.createElement('canvas')
                    
					dot_canvas.id = "dot_" + this.id
                    dot_canvas.className = "dot_holder"
                    dot_canvas.style.position = "absolute";
                    dot_canvas.style.text = this.id
                    dot_canvas.style.margin = -(center) + "px", 0, 0, -(center) + "px"
                    dot_canvas.style.left = this.coords["x"] + "px"
                    dot_canvas.style.top = this.coords["y"] + "px"
                    
                    dot_canvas.width = center*2
                    dot_canvas.height = center*2

                    document.getElementById("circle").appendChild(dot_canvas)

                    return dot_canvas
			
				}

				move() {
					var dot_canvas = document.getElementById("dot_" + this.id)	
					dot_canvas.style.left = this.coords["x"] + "px"
					dot_canvas.style.top = this.coords["y"] + "px"
					
					if (debug_showstoppers) {
						check_dots_going_outside(this)
					}
					return
				}
				
				set_coords() {
					this.coords_theory["x"] = this.next_coords_theory["x"] 
					this.coords_theory["y"] = this.next_coords_theory["y"]
					this.coords["x"] = Math.round(this.coords_theory["x"])
					this.coords["y"] = Math.round(this.coords_theory["y"])

					return
				}
			
				determine_next_coords() {
					this.next_coords_theory["x"] = round_calc_general(this.coords_theory["x"] + this.course["x"])
					this.next_coords_theory["y"] = round_calc_general(this.coords_theory["y"] + this.course["y"])

					return
				}

				manage_sections_setting() {
					this.grid_spots = []

					// start situation
					this.get_set_section(this.coords_theory)

					// for end situation
					this.get_set_section(this.next_coords_theory)

					// get square in grid from minimum and maximum 
					// position in start and end situation
					this.determine_all_sections()	

					return
				}
			
				determine_all_sections() {
					var x_min = Infinity 
					var y_min = Infinity
					var x_max = -Infinity
					var y_max = -Infinity

					for (var p=0;p<this.grid_spots.length;p++) {

						if (this.grid_spots[p]["x"]<x_min) {
							x_min = this.grid_spots[p]["x"]	
						}
						if (this.grid_spots[p]["x"]>x_max) {
							x_max = this.grid_spots[p]["x"]
						}
						if (this.grid_spots[p]["y"]<y_min) {
							y_min = this.grid_spots[p]["y"]	
						}
						if (this.grid_spots[p]["y"]>y_max) {
							y_max = this.grid_spots[p]["y"]
						}

					}

					// this list is cleared and than reused					
					this.grid_spots = []

					for (var x=x_min;x<=x_max;x++) {
						for (var y=y_min;y<=y_max;y++) {
							this.grid_spots.push({type: "dot",
												  obj: this, 
												  x: x, 
												  y: y})
						}
					}
					return	
				}

				get_set_section(coords) {
					this.grid_spots.push(this.calc_section(coords["x"], 
														   coords["y"]))

					var pi_steps = (2*Math.PI) / circle_resolution
					for (var c_res=0;c_res<circle_resolution;c_res++) {
						
						// NOTE: cl stands for circle edge
						var x_ce = Math.cos(pi_steps*c_res) * this.radius
						var y_ce = Math.sin(pi_steps*c_res) * this.radius

						var grid_section_next = this.calc_section(coords["x"] + x_ce, 
																  coords["y"] + y_ce)
						
						this.grid_spots.push(grid_section_next)
					}

					return
				}

				calc_section(coord_x, coord_y) {
					var section_x = coord_x / section_size["x"]
					var section_y = coord_y / section_size["y"]
					var grid_section_x = Math.floor(section_x+1)
					var grid_section_y = Math.floor(section_y+1)
					
					return {x: grid_section_x, 
							y: grid_section_y}
				}


			} // end Dot class

			class Track_collision {
				constructor() {
					this.set= false
					this.obj_1 = undefined
					this.obj_2 = undefined
				}

				setter(obj_1, obj_2) {

					this.obj_1 = obj_1
					this.obj_2 = obj_2
					this.set = true

					obj_2.track_collision = this

					return
				}
						
				manage_reset(other_obj) {

					if (this.set) {
						this.reset_clean()
					} 
					
					if (other_obj.track_collision.set) {
						other_obj.track_collision.reset_clean()
					}

					return
				}
				
				reset_clean() {
					
					this.obj_1.track_collision = new Track_collision()
					this.obj_2.track_collision = new Track_collision()
				
					return	
				}

				check_previous(other_obj) {

					if (!this.set) {
						return false
					}
				
					if (this.obj_1==other_obj || this.obj_2==other_obj) {
						return true
					}

					return false
				}
			} // end Track_collision class

		</script>

	</head>


	<body>

		<div id="circle" style="position:relative;">
		
			<div id="timer_div" style="position:absolute; text-align:center; bottom:0; color:red;">0</div>

		</div>

	</body>

</html>






